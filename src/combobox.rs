//! ## Required fields
//!
//! * `items` Function that supplies the list of items in the combo box
//!
//! ## Optional fields
//!
//! * `label` override widget label.
//! * `catch`
//! * `map` Applies a mapping function to `&mut Self` (works the same as in the
//!   [input example](../input/index.html#mapping))
//!
//! ## Example
//!
//! ```
//! #[derive(imgui_ext::Gui)]
//! struct Combobox {
//!     #[imgui(combobox(label = "Combobox!", items = "combo_items"))]
//!     selected: bool,
//! }
//!
//! // Must pass current items to the callback function for them to be displayed
//! fn combo_items<F>(mut callback: F)
//! where F: FnMut(&[&ImStr]) {
//!     callback(&[
//!         im_str!("Foo"),
//!         im_str!("Bar"),
//!         im_str!("Baz")
//!     ])
//! }
//! ```
//!
//! ### Result
//!
//! ![][result]
//!
//! [result]:
use imgui::{ImStr, Ui};

/// Structure generated by the annoration.
pub struct ComboboxParams<'a> {
    pub label: &'a ImStr,
    pub items: &'a [&'a ImStr],
}

/// Trait for types that can be represented with a combobox.
pub trait Combobox {
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool;
}

impl<C: Combobox> Combobox for Option<C> {
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        if let Some(ref mut elem) = elem {
            C::build(ui, elem, params)
        } else {
            false
        }
    }
}

impl Combobox for usize { // TODO: Other types
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        imgui::ComboBox::new(params.label).build_simple_string(ui, elem, &params.items)
    }
}

impl<T: Combobox> Combobox for Box<T> {
    #[inline]
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        T::build(ui, elem, params)
    }
}
